import axios from 'axios';
import { isUndefined, last, omit, pick } from 'lodash-es';
import urlJoin from 'url-join';
import { parseTemplate } from 'url-template';
import { stringifyQueryParams } from '../utils/stringifyQueryParams.js';
const SLASH = '/';
export class Agent {
    constructor({ client, path = '/', getUrlParams = () => ({}), getBaseUrl = () => client.baseUrl, }) {
        this.client = client;
        this.getBaseParams = getUrlParams;
        this.getBaseUrl = getBaseUrl;
        this.basePath = path;
    }
    request({ method, path = '', urlParamKeys = [], queryParamKeys = [], catchNotFound = false, keyTransform, payloadKey, returnResourceIdInLocationHeader, ignoredKeys, headers, }) {
        return async (payload = {}, options) => {
            const baseParams = this.getBaseParams?.() ?? {};
            const queryParams = queryParamKeys ? pick(payload, queryParamKeys) : null;
            const allUrlParamKeys = [...Object.keys(baseParams), ...urlParamKeys];
            const urlParams = { ...baseParams, ...pick(payload, allUrlParamKeys) };
            const omittedKeys = ignoredKeys
                ? [...allUrlParamKeys, ...queryParamKeys].filter((key) => !ignoredKeys.includes(key))
                : [...allUrlParamKeys, ...queryParamKeys];
            payload = omit(payload, omittedKeys);
            if (keyTransform) {
                this.transformKey(payload, keyTransform);
                this.transformKey(queryParams, keyTransform);
            }
            return this.requestWithParams({
                method,
                path,
                payload,
                urlParams,
                queryParams,
                catchNotFound,
                ...(this.client.getGlobalRequestArgOptions() ?? options ?? {}),
                payloadKey,
                returnResourceIdInLocationHeader,
                headers,
            });
        };
    }
    updateRequest({ method, path = '', urlParamKeys = [], queryParamKeys = [], catchNotFound = false, keyTransform, payloadKey, returnResourceIdInLocationHeader, headers }) {
        return async (query = {}, payload = {}) => {
            const baseParams = this.getBaseParams?.() ?? {};
            const queryParams = queryParamKeys ? pick(query, queryParamKeys) : null;
            const allUrlParamKeys = [...Object.keys(baseParams), ...urlParamKeys];
            const urlParams = {
                ...baseParams,
                ...pick(query, allUrlParamKeys),
            };
            if (keyTransform) {
                this.transformKey(queryParams, keyTransform);
            }
            return this.requestWithParams({
                method,
                path,
                payload,
                urlParams,
                queryParams,
                catchNotFound,
                payloadKey,
                returnResourceIdInLocationHeader,
                headers,
            });
        };
    }
    async requestWithParams({ method, path, payload, urlParams, queryParams, catchNotFound, payloadKey, returnResourceIdInLocationHeader, headers }) {
        const newPath = urlJoin(this.basePath, path);
        const pathTemplate = parseTemplate(newPath);
        const parsedPath = pathTemplate.expand(urlParams);
        const url = `${this.getBaseUrl?.() ?? ''}${parsedPath}`;
        const requestConfig = {
            paramsSerializer: (params) => stringifyQueryParams(params),
            ...(this.client.getRequestConfig() || {}),
            method,
            url,
        };
        requestConfig.headers = {
            ...requestConfig.headers,
            Authorization: `bearer ${await this.client.getAccessToken()}`,
            ...headers
        };
        if (method === 'GET') {
            requestConfig.params = payload;
        }
        else {
            requestConfig.data = payloadKey ? payload[payloadKey] : payload;
        }
        if (queryParams) {
            requestConfig.params = requestConfig.params
                ? {
                    ...requestConfig.params,
                    ...queryParams,
                }
                : queryParams;
        }
        try {
            const res = await axios.default(requestConfig);
            if (returnResourceIdInLocationHeader) {
                const locationHeader = res.headers.location;
                if (typeof locationHeader !== 'string') {
                    throw new Error(`location header is not found in request: ${res.config.url}`);
                }
                const resourceId = last(locationHeader.split(SLASH));
                if (!resourceId) {
                    throw new Error(`resourceId is not found in Location header from request: ${res.config.url}`);
                }
                const { field } = returnResourceIdInLocationHeader;
                return { [field]: resourceId };
            }
            return res.data;
        }
        catch (err) {
            if (axios.default.isAxiosError(err) && err.response?.status === 404 && catchNotFound) {
                return null;
            }
            throw err;
        }
    }
    transformKey(payload, keyMapping) {
        if (!payload) {
            return;
        }
        Object.keys(keyMapping).some((key) => {
            if (isUndefined(payload[key])) {
                return false;
            }
            const newKey = keyMapping[key];
            payload[newKey] = payload[key];
            delete payload[key];
        });
    }
}
//# sourceMappingURL=agent.js.map